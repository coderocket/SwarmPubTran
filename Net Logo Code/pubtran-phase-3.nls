; TODO: the passenger must select the best available bus and not just a suitable bus
; otherwise it may end up taking a bus that brings it close to its destination while
; avoiding a bus that brings it exactly to its destination.

; TODO: if there are more buses than bees then assign buses to bees based on the amount
; of passengers dropped by each bee.

; a bus has a capacity (number of passengers it can carry)
; an occupancy )number of passengers linked to it) always less than its
; capacity) a route and a station indicating the last station
; that the bus has visited. A route is a sequence of stations
; (each station is simply a patch coordinate). The route's
; origin is the first station, its destination is the last
; station.

globals [first-bus-id]

breed [buses bus]

buses-own [
  capacity
  occupancy
  station
  route
  speed
]

to setup-phase-3
  set phase 3
  remove-loops-from-routes
  concat-bees-until
  setup-buses
  set first-bus-id min [who] of buses
  ask bees [die]
end

to remove-loops-from-routes 
  ask bees [
    set route remove-loops route
  ]
end

to merge-bees
  ask bees [
    let a-subsuming-bee one-of other bees with [ is-sublist [route] of myself route ]
    if a-subsuming-bee != nobody
    [ die ]
  ]
end

to concat-bees-until 
  
  let epsilon 0 
  
  while [count bees > number-of-buses]
  [ 
    merge-bees
    pick-best-bees
    concat-adjacent-bees epsilon 
    set epsilon epsilon + 1 ]
  
end

to concat-adjacent-bees [epsilon]
  ask bees [
    let an-extending-bee one-of other bees with [ [ distance [destination] of myself ] of ([first route] of myself) <= epsilon ]
    if an-extending-bee != nobody and count bees > number-of-buses
    [      
      set route sentence route [route] of an-extending-bee
      set destination [destination] of an-extending-bee
      set drop-count drop-count + [drop-count] of an-extending-bee
      ask an-extending-bee [die] 
    ]
  ]
end

to-report remove-loops [ a-list ]
  ifelse empty? a-list
  [report a-list]
  [let new-list remove-loops but-first a-list
    let p position first a-list new-list
    ifelse p = false
    [report fput first a-list new-list]
    [report fput first a-list sublist new-list (p + 1) length new-list] ]
end

to pick-best-bees
  ask bees [
    if any? other bees with [ first route = [first route] of myself 
      and destination = [destination] of myself 
      and drop-count > [drop-count] of myself ]
    [die ]
  ]
end  

; we call this action only when there are at least as many buses as bees
; that is, count buses >= count bees

to setup-buses
  set-default-shape buses "bus"

 ; foreach [route] of bees [ x ->
    
  create-buses number-of-buses [
      set size 2
      set capacity bus-capacity
      set occupancy 0
      set station 0
      set route nobody
      set speed 1
  ] 
  
 ; ]
  
  ; assign one bus to every bee
  
  ask bees [
    let a-bus one-of buses with [ route = nobody ]
    ask a-bus [ 
      set route [route] of myself 
      set xcor [pxcor] of first route
      set ycor [pycor] of first route
    ]
  ]
  
  ; all the buses that were not assigned go to bees based on their score
  
  let sorted-bees sort-by [ [ x y ] -> [ drop-count ] of x > [ drop-count ] of y ] bees
  
  while [ any? buses with [ route = nobody ] ] 
  [
    foreach sorted-bees [ b -> 
      let a-bus one-of buses with [route = nobody ]
      if a-bus != nobody
      [ 
        ask a-bus [
          set route [route] of b
          set xcor [pxcor] of first route
          set ycor [pycor] of first route
        ]
      ]
    ]
  ]
  
end

; GO PHASE 3

to go-phase-3
  ask passengers [move-passenger]
  ask buses [move-bus]
  tick
end

to move-bus
  
  if who - first-bus-id > ticks / 10
  [stop]
  
  ifelse at-destination
  [ set route reverse route
    set station 0
  ]
  [ ifelse at-next-station
    [ set station station + 1 ]
    [ face item (station + 1) route
      fd speed
      set speed 1
  ] ]
end

to take-passenger [ aPassenger ]
  create-link-to aPassenger [ tie ]
  set occupancy occupancy + 1
  ask aPassenger [
    setxy [xcor] of myself [ycor] of myself
  ]
end

to move-passenger
  set trip-time trip-time + 1
  ifelse patch-here = destination or member? destination neighbors
  [ if on-a-bus != nobody
    [ ask on-a-bus [ set occupancy occupancy - 1 ] ]
    die]
  [ ifelse on-a-bus != nobody
    [ if patch-here = get-off-station
      [ ask on-a-bus [ set occupancy occupancy - 1 ]
        ask my-links [
          die
          ]
        setxy pxcor pycor
        set on-a-bus nobody ]
    ]
    [
      ; board a non full bus that passes through a station
      ; that is as close as possible to the passenger's destination
      let the-passenger-destination destination
      ;let theBus min-one-of (buses-here with [ occupancy < capacity and length remaining-stations > 0]) [ [distance [destination] of the-passenger ] of station-nearest-to [destination] of myself ]
      ;let theBus min-one-of buses-here [ [distance [destination] of the-passenger ] of station-nearest-to [destination] of myself ]
      let theBus one-of buses-here with [ member? the-passenger-destination route ]
      ifelse theBus = nobody
      [ ;show "no bus" 
        ;show self 
      ]
      [ let best-station-patch ([station-nearest-to [destination] of myself] of theBus)
        ifelse distance destination > [distance [destination] of myself] of best-station-patch 
        and [ occupancy ] of theBus < [capacity] of theBus
        and trip-time >= max [trip-time] of passengers-here ; give priority to passengers waiting longer
        [ board-bus theBus] 
        [; show "no good bus"
         ; show self
         ; show best-station-patch
         ; show distance destination
         ; show [distance [destination] of myself] of best-station-patch 
          ]
      ]
  ] ]
end

to board-bus [ aBus ]
  set on-a-bus aBus
  set get-off-station [station-nearest-to [destination] of myself] of aBus
  ask aBus [
    take-passenger myself
    set speed random-float 1.0
  ]
end

; a passenger will board a bus if one of the stations along the buse's route
; will move him closer to his or her destination than his or her current
; position. the passenger will get off the bus at the station that brings him
; or her closest to their destination.

to-report station-nearest-to [dest]
  report reduce
  [ [best-so-far next-station] ->
    ifelse-value ([distance dest] of next-station  < [distance dest] of best-so-far)
    [next-station]
    [best-so-far] ]
;  remaining-stations
  route
end

to-report remaining-stations
  report sublist route (station + 1) length route
end

to-report at-destination
  report station = length route - 1
end

to-report at-next-station
  report patch-here = item (station + 1) route
end


